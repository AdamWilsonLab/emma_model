---
format:
  html:
    code-fold: true
    code-summary: "Show the code"
---

# Examining model output

## Full model is:    
    mu[i] = alpha[pid[i]]+gamma[pid[i]]-gamma[pid[i]]*exp(-(age[i]/lambda[pid[i]]))+
    sin((phi+((firemonth[i]-1)*3.141593/6))+6.283185*age[i])*A[pid[i]];

```{r load code}
#| results: hide
#| include: false

library(tidyverse,quietly = TRUE,verbose = FALSE)
library(targets)

    #   list.files("R",pattern="[.]R",full.names = T) %>%
    # stringr::str_subset(c("R/detect_anomalies.R"), negate=TRUE) %>%
    #   stringr::str_subset(c("R/predict_the_future.R"), negate=TRUE) %>%
    #   stringr::str_subset(c("R/predict_from_model.R"), negate=TRUE) %>%
    #   stringr::str_subset(c("R/predict_from_model_draws.R"), negate=TRUE) %>%
    # lapply( source)

  tar_load(model_results)
  tar_load(data_training)
  tar_load(stan_data)

  
```


# List model parameters

```{r get model parms}

model_results %>%
  select(parameter)%>%
  unique()-> parms_in_model

parms_in_model %>%
  pull(parameter)





```

# Run some basic sanity checks

```{r sanity checks}

# load the summary
  tar_load(model_mcmc_summary_postfire_season2)


# Sanity checks

  
# Parameters

  #model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="alpha[",fixed = TRUE,x=variable)) -> alpha_estimates
  
  # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="gamma[",fixed = TRUE,x=variable)) -> gamma_estimates

  # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="lambda[",fixed = TRUE,x=variable)) -> lambda_estimates

  # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="A[",fixed = TRUE,x=variable)) -> A_estimates


# Hyperparameters 
  
    #model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="^gamma_mu\\[",perl = TRUE,x=variable)) -> gamma_mu_estimates
    
    # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
      filter(grepl(pattern="^lambda_mu\\[",perl = TRUE,x=variable)) -> lambda_mu_estimates
    
    # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="^A_mu\\[",perl = TRUE,x=variable)) -> A_mu_estimates
    
    # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="^gamma_beta\\[",perl = TRUE,x=variable)) -> gamma_beta_estimates
  
    # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="^lambda_beta\\[",perl = TRUE,x=variable)) -> lambda_beta_estimates
    
    # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="^mu\\[",perl = TRUE,x=variable)) -> mu_estimates
  
    # model_mcmc_summary_postfire_season2 %>%
    model_results %>%
    filter(grepl(pattern="y_pred\\[",perl = TRUE,x=variable)) -> y_pred_estimates

  
# Parameters
        
    # alpha estimates should be of length J
      
      if(nrow(alpha_estimates) != stan_data$J){stop("incorrect number of alpha estimates")}
        
    # gamma estimates should be of length J
      
      if(nrow(gamma_estimates) != stan_data$J){stop("incorrect number of gamma estimates")}
    
    # lambda estimates should be of length J
      
      if(nrow(lambda_estimates) != stan_data$J){stop("incorrect number of lambda estimates")}
        
    # A estimates should be of length J
      
      if(nrow(A_estimates) != stan_data$J){stop("incorrect number of A estimates")}
    
# Hyper parameters    
    
    # gamma_mu estimates should be of length J
      
      if(nrow(gamma_mu_estimates) != stan_data$J){stop("incorrect number of gamma mu estimates")}
    
    # lambda_mu estimates should be of length J
      
      if(nrow(lambda_mu_estimates) != stan_data$J){stop("incorrect number of lambda mu estimates")}
    
    # A_mu estimates should be of length J
      
      if(nrow(A_mu_estimates) != stan_data$J){stop("incorrect number of A mu estimates")}
        
        
    # lambda beta should be of length
        if(nrow(lambda_beta_estimates) != ncol(stan_data$x)){stop("incorrect number of lambda beta estimates")}
    
    # gamma beta should be of length
        if(nrow(gamma_beta_estimates) != ncol(stan_data$x)){stop("incorrect number of gamma beta estimates")}

# mu should be the same length as pid 
    
  if(length(stan_data$pid) != nrow(mu_estimates)){stop("incorrect number of mu estimates")}
    
# mu should be of length N
    
  if(stan_data$N  != nrow(mu_estimates)){stop("incorrect number of mu estimates")}

    
# y pred should be length mu
    
  if(nrow(y_pred_estimates)  != nrow(mu_estimates)){stop("incorrect number of y pred estimates")}

```


# Model checking

The goal here is to start at the lowest level of the model and work our way up to make sure we can reproduce things from R

## alpha

### alpha mu

```{r alpha mu}

  #alpha ~ normal(alpha_mu, alpha_tau)  

model_results%>%
  filter(parameter %in% c("alpha_mu", "alpha_tau")) -> alpha_mu_and_tau

# we'll generate a set of 100 estimates for each alpha parameter. These should all be approximately the same

alpha_mu_pred_r <- replicate(n = 100,
          expr = rnorm(n = nrow(alpha_estimates),
                       mean = alpha_mu_and_tau %>%
                         filter(parameter=="alpha_mu") %>%
                         pull(mean),sd = alpha_mu_and_tau %>%
                         filter(parameter=="alpha_mu") %>%
                         pull(sd)))

#alpha_seq <-seq(-1,1,length.out=100000)
alpha_seq <-unique(as.vector(alpha_mu_pred_r))

data.frame(alpha_mu_pred_r = alpha_mu_pred_r %>%
  as.vector())%>%
  ggplot(mapping = aes(x=alpha_mu_pred_r))+
  geom_density(fill="blue",alpha=0.5)+
  geom_line(data = data.frame(alpha = alpha_seq,
                               density = dnorm(x = alpha_seq,
      mean = alpha_mu_and_tau %>%
        filter(variable=="alpha_mu")%>%
        pull(mean),
      sd = alpha_mu_and_tau %>%
        filter(variable=="alpha_mu")%>%
        pull(sd))),
      mapping = aes(x=alpha,y=density),color="red")+
  ggtitle("Red = density given the mean and sd; blue = density from estimates in R ")
  
  

```

### alpha tau

```{r alpha tau}

  #alpha ~ normal(alpha_mu, alpha_tau)
  #alpha_tau = sqrt(alpha_tau_sq)

model_results%>%
  filter(parameter %in% c("alpha_tau", "alpha_tau_sq")) -> alpha_tau_and_alpha_tau_sq

# we'll generate a set of 100 estimates for each alpha parameter. These should all be approximately the same

alpha_tau_pred_r <- replicate(n = 100,
          expr = rnorm(n = nrow(alpha_estimates),
                       mean = alpha_mu_and_tau %>%
                         filter(parameter=="alpha_tau") %>%
                         pull(mean),sd = alpha_mu_and_tau %>%
                         filter(parameter=="alpha_tau") %>%
                         pull(sd)))

#alpha_seq <-seq(-1,1,length.out=100000)
alpha_seq <-unique(as.vector(alpha_tau_pred_r))

data.frame(alpha_tau_pred_r = alpha_tau_pred_r %>%
  as.vector())%>%
  ggplot(mapping = aes(x=alpha_tau_pred_r))+
  geom_density(fill="blue",alpha=0.5)+
  geom_line(data = data.frame(alpha = alpha_seq,
                               density = dnorm(x = alpha_seq,
      mean = alpha_mu_and_tau %>%
        filter(variable=="alpha_tau")%>%
        pull(mean),
      sd = alpha_mu_and_tau %>%
        filter(variable=="alpha_tau")%>%
        pull(sd))),
      mapping = aes(x=alpha,y=density),color="red")+
  ggtitle("Red = density given the mean and sd; blue = density from estimates in R ")
  
  

```

### Can we get alpha right from R?

```{r alpha model vs R}
#| fig-cap: 'Red: density plot of mean alpha values from the fitted stan model. Blue: density plot of mean alpha values estimated with R.'
 
alpha_pred_r <-apply(X = array(c(alpha_mu_pred_r,alpha_tau_pred_r),
                               dim=c(dim(alpha_mu_pred_r),2)),
                     MARGIN = c(1,2),
                     FUN = function(x){rnorm(n=1,mean=x[1],sd = x[2])})


alpha_pred_r_summary <- apply(alpha_pred_r, MARGIN = 1,
                              FUN = function(x){c(mean=mean(x),sd=sd(x))}) %>%
  t() %>% as.data.frame()

if( min(alpha_pred_r)< -1 | max(alpha_pred_r) > 1){message("Impossible alpha pred values found")}

model_results %>%
  filter(parameter == "alpha")%>%
  ggplot(mapping = aes(x=mean))+
  geom_density(fill="red",alpha=0.5)+
  
  geom_density(data = data.frame(pred_alpha = alpha_pred_r_summary$mean),
               mapping = aes(x=pred_alpha),fill="blue",alpha=0.5)+
  
  ggtitle("red = alpha from fit, blue = alpha predicted in R")
  
message("Brian, add plot of density from parms here")  


```

Estimates of alphas from R differ from those from STAN. The R values are more consistent with the alpha mean (`r alpha_mu_and_tau %>% filter(parameter=="alpha_mu") %>% pull(mean)%>% as.numeric()`) and SD (`r alpha_mu_and_tau %>% filter(parameter=="alpha_tau") %>% pull(mean)%>% as.numeric()`) estimated by STAN.

### Alpha predicted from generated quantities block

```{r alpha estimates from stan}

# 
# model_results %>%
#   filter(parameter == "alpha")%>%
#   ggplot(mapping = aes(x=mean))+
#   geom_density(fill="red",alpha=0.5)+
#   
#   geom_density(data = model_results%>%
#   filter(parameter=="alpha_pred"),
#                mapping = aes(x=mean),fill="blue",alpha=0.5)+
#   
#   ggtitle("red = alpha from fit, blue = alpha predicted in generated quantities")


# model_results%>%
#   filter(parameter=="alpha_pred")


```

## gamma

gamma ~ lognormal(gamma_mu,gamma_tau)
gamma_mu = x*gamma_beta
gamma_tau = sqrt(gamma_tau_sq)

```{r gamma mu}

# gamma ~ lognormal(gamma_mu,gamma_tau)
# gamma_mu = x*gamma_beta
# gamma_tau = sqrt(gamma_tau_sq)


model_results %>%
  filter(parameter %in% c("gamma_mu")) -> gamma_mu_estimates

model_results %>%
  filter(parameter %in% c("gamma_tau")) -> gamma_tau_estimates

model_results %>%
  filter(parameter %in% c("gamma_beta")) -> gamma_beta_estimates

model_results %>%
  filter(parameter %in% c("gamma")) -> gamma_estimates



```

## lambda

## A (amplitude)

## Is y_obs \~ normal(mu,tau)?

```{r y vs mu}


#current model is 
  # y_obs ~ normal(mu, tau)  
  # mu[i] = alpha[pid[i]];

y_obs <- data.frame(y_obs =stan_data$y_obs,
           uid = 1:stan_data$N,
           pid=stan_data$pid  )

  mu_estimates %>%
    select(mean,pid,uid)%>%
    mutate(uid = as.integer(uid))%>%
    rename(mu_mean=mean)%>%
    left_join(y = y_obs  ,by="uid")-> mus_and_y_obs



  mus_and_y_obs %>%
    ggplot(mapping = aes(y=y_obs,x=mu_mean))+
    geom_point()+
    geom_smooth(method = "lm",color="pink")+
    geom_abline(slope = 1,intercept = 0,color="blue")
    

  
```


Seems reasonable, but the above doesn't take into account tau

# Do predictions look ok?

## model preds


